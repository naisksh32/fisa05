250707 [Python] (4일차)
=======================

<hr/>

## Keep: 잘 했기 때문에 유지하고 싶은 것
    1.

## Problem: 어려움을 느껴 개선하고 싶은 것
    1.

## Try: 구체적으로 시도할 내용
    1.

<hr/>

### 1. 함수형 프로그래밍
1. 절차형(Procedure) 프로그래밍
    - 내가 원하는 결과를 도출하기 위한 순서(절차) 중심으로 프로그래밍 하는 방법
    - 소스코드를 함수단위로 관리
        - 언제든 호출할 수 있다. -> 재사용성이 증가
        - 소스코드의 양도 줄어든다
        - 관리도 편해진다
    - 파이썬은 함수만 이용해서 코딩할 수 있다.
2. 객체지향 프로그래밍
    - 함수 단위로 소스코드를 작성해서 해결이 안되는 문제들이 있다.
    비슷한 주제 중심으로 변수나 함수를 묶어서 관리하는 객체지향 프로그래밍이 두각을 나타낸다
    - 해당 객체의 속성, 동작(메서드)를 주제 단위로 묶어놓고 속성/동작을 관리하기 위해서 클래스 라는 개념이 도입
3. 함수형 프로그래밍
![](http://www.tcpschool.com/lectures/img_codingmath_16.png)
    - 상태 변경과 부작용을 피하고, 데이터를 변환하는 함수를 조합하는 스타일
    - 순수 함수: 같은 입력이면 항상 같은 출력
    - 불변(Immutable) 데이터 - 데이터를 한 번 만들면 바꿀 수 없다.
    - 고차 함수(함수를 인자로 받거나 반환)
    - 게으른 평가 (필요할 때만 계산)

    - 함수형 언어들은 반복문이 필요 없다
    - 반복이 필요하면 - 재귀를 이용해서 표현

- #### List Comprehebnsion
    간단하게 리스트를 생성

        [(변수에 적용할 수식) for (변수) in (for문이 돌아가는 범위)]

    2의 배수를 가진 리스트 생성

        [i for i in range(0,11,2)]
        [i for i in range(11) if i%2 == 0]

    연산을 할 때에만 메모리에 추가하고, 쓰고 나서는 메모리에서 없앰으로 메모리 관리 측면에서 효율을 보임

    리스트 말고도 tuple, dictionary 모두 만들 수 있음

        {k:v for k, v in scores.items() if v>=80}

- ##### Map
    - 시퀸스 자료형. 각 요소에 동일한 함수를 적용할 대
    - map 함수가 반환한 객체는 반복 가능한(iterable) 객체
    - 실행시점에 값을 생성하기 때문에 메모리 효율적

            map((적용할 함수 - 주로 lambda 함수), (리스트 데이터))

            [*map(lambda x: x+1), list_a]
            # 2, 3, 4, 5 ~

- ##### filter
    - iterable 각 요소에 대해 function이 참인 것만 반환하는 요소의 이터레이터

            fiter(function, iterable)
        
            [*filter(lambda x: x%2==0), (list_a)]
            # 2, 4, 6, 8 ~

- ##### Enumerate & Zip
    - Enumerate(열거하다)
        - 리스트의 요소를 추출할 때 번호를 붙여서 추출해 줍니다.

                enumerate(리스트)
                # (0, a[0]), (1, a[1]), (2, a[2]) ~
    - Zip(잠그다)
        - 두개의 리스트를 병렬적으로 추출함

                zip(list1, list2)
                # (a[0], b[0]), (a[1], b[1]), (a[2], b[2])
        - 단, 리스트의 갯수가 제일 적은 것으로 결정 됨

- ##### Reduce
    - reduce는 반복 가능한 객체의 각 요소를 지정된 함수로 처리한 뒤 이전 결과와 누적해서 반환
    - 내장 함수가 아니라 functools 모듈에서 reduce 함수를 가져와야 함

            reduce(function, iterable, initalizer=None)
    
            reduce(lambda x,y: x+y, array2dim)
            # [[], [1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
            #  []  [1]
            # -----------
            #           [2, 2]
            # ---------------------
            #                    [3, 3, 3]
            # -------------------------------
            #                               [4, 4, 4, 4]

            => [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]

- ##### Generator
    - yield 키워드를 사용하여 iterator를 반환하는 특별한 함수
    - 일반 함수와 달리 한번에 모든 값을 반환하지 않고 필요할 때마다 하나씩 값을 생성(계산)한다.
    - 이를 통해 메모리 사용을 최소화 하고, 큰 데이터셋이나 무한 시퀸스 같은 상황에서도 효율적으로 데이터를 처리할 수 있다.

            def generator_squares():
                for x in range(10):
                    yield x*x
            
            squares = generator_squares()

            print(next(squares)) # 0*0
            print(next(squares)) # 1*1
            print(next(squares)) # 2*2
            # ~~~
            print(next(squares)) # 9*9
            print(next(squares)) # StopIteration Error 발생 - 한도를 벗어남

- 표준 출력
    - print(value, sep='', end='\n', file=sys.stdout, flush=False)
    - value: 표현할 값
    - sep: 구분자
    - end: 끝날 때 연결할 것
    - file: 어떤 파일을 열 것인가?
    - flush: 매번 반영할 것인지

- 외부 파일 열기
    - 항상 open이 있으면 close도 있어야 한다.
    - open 시 (w:쓰기모드, r:읽기모드, a:추가모드) 설정
    - close 전 까지는 메모리에 해당내용을 기록하고 있어 반영이 되지 않는다.
    - close가 된다면 비로소 메모리에 있는 내용들이 기록 된다.
    - with를 사용하면 자동적으로 끝나는 부분에 close가 실행된다.

- flush
    - 스트림 객체로 바꿔서 출력을 해주고 있다 라는 뜻.
    - 객체를 그때그때 잘라서 보낸다.

### 2. 문자열 메소드
- rowString: 문자열을 있는 그대로 표현하기 위해 사용

        # 멀티라인 따옴표 3개
        # 공백, 엔터도 문자로 처리
        """안
        녕
        하
        세요
        """
        # 안\n녕\n하\n세요\n

        print('C:\0ITStudy')
        # C:ITStudy
        print(r'C:\0ITStudy')
        # C:\0ITStudy

- split('기준문자', 분리 횟수): 문자열에서 '기준문자'를 기준으로 분리횟수만큼 분리한 문자열의 **리스트**를 반환

        str1 = '안녕/안녕/안녕하세요/반가워요/좋은아침입니다'

        str1.split('/', 2)
        # ['안녕', '안녕', '안녕하세요/반가워요/좋은아침입니다']


### 3. 3번항목

