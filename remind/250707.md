250707 [Python] (4일차)
=======================

<hr/>

## Keep: 잘 했기 때문에 유지하고 싶은 것
    1. 어려운 문자열을... 끝가지 잘 따라간 것?

## Problem: 어려움을 느껴 개선하고 싶은 것
    1. 숫자 자료형과는 다르게 문자 자료형은 표현은 쉽지만 다루기 어렵다.
    그 이유로 첫번째는 보이지 않는 튜플형태로 오기 때문에 리스트의 자료형을 잘 다루어야 한다
    두번째로는 정규식에서 특정 패턴을 지정하는것이 아직 익숙치 않다.
    마지막으로 값만 잘 맞다면 숫자형 자료형과 문자형 자료형은 서로 형변환이 자유롭다.
    이러한 이유들 때문에 문자열을 배우는 것이 아직 조금 벅차다고 생각한다.

## Try: 구체적으로 시도할 내용
    1. 정규식의 패턴을 찾는 연습을 더 해야겠다.
    GPT에게 파이썬의 문자 정규식에 관한 예제들을 물어보고, 이들의 패턴을 찾는 연습을 해야겠다.

<hr/>

### 1. 함수형 프로그래밍
1. 절차형(Procedure) 프로그래밍
    - 내가 원하는 결과를 도출하기 위한 순서(절차) 중심으로 프로그래밍 하는 방법
    - 소스코드를 함수단위로 관리
        - 언제든 호출할 수 있다. -> 재사용성이 증가
        - 소스코드의 양도 줄어든다
        - 관리도 편해진다
    - 파이썬은 함수만 이용해서 코딩할 수 있다.
2. 객체지향 프로그래밍
    - 함수 단위로 소스코드를 작성해서 해결이 안되는 문제들이 있다.
    비슷한 주제 중심으로 변수나 함수를 묶어서 관리하는 객체지향 프로그래밍이 두각을 나타낸다
    - 해당 객체의 속성, 동작(메서드)를 주제 단위로 묶어놓고 속성/동작을 관리하기 위해서 클래스 라는 개념이 도입
3. 함수형 프로그래밍
![](http://www.tcpschool.com/lectures/img_codingmath_16.png)
    - 상태 변경과 부작용을 피하고, 데이터를 변환하는 함수를 조합하는 스타일
    - 순수 함수: 같은 입력이면 항상 같은 출력
    - 불변(Immutable) 데이터 - 데이터를 한 번 만들면 바꿀 수 없다.
    - 고차 함수(함수를 인자로 받거나 반환)
    - 게으른 평가 (필요할 때만 계산)

    - 함수형 언어들은 반복문이 필요 없다
    - 반복이 필요하면 - 재귀를 이용해서 표현

- #### List Comprehebnsion
    간단하게 리스트를 생성

        [(변수에 적용할 수식) for (변수) in (for문이 돌아가는 범위)]

    2의 배수를 가진 리스트 생성

        [i for i in range(0,11,2)]
        [i for i in range(11) if i%2 == 0]

    연산을 할 때에만 메모리에 추가하고, 쓰고 나서는 메모리에서 없앰으로 메모리 관리 측면에서 효율을 보임

    리스트 말고도 tuple, dictionary 모두 만들 수 있음

        {k:v for k, v in scores.items() if v>=80}

- ##### Map
    - 시퀸스 자료형. 각 요소에 동일한 함수를 적용할 대
    - map 함수가 반환한 객체는 반복 가능한(iterable) 객체
    - 실행시점에 값을 생성하기 때문에 메모리 효율적

            map((적용할 함수 - 주로 lambda 함수), (리스트 데이터))

            [*map(lambda x: x+1), list_a]
            # 2, 3, 4, 5 ~

- ##### filter
    - iterable 각 요소에 대해 function이 참인 것만 반환하는 요소의 이터레이터

            fiter(function, iterable)
        
            [*filter(lambda x: x%2==0), (list_a)]
            # 2, 4, 6, 8 ~

- ##### Enumerate & Zip
    - Enumerate(열거하다)
        - 리스트의 요소를 추출할 때 번호를 붙여서 추출해 줍니다.

                enumerate(리스트)
                # (0, a[0]), (1, a[1]), (2, a[2]) ~
    - Zip(잠그다)
        - 두개의 리스트를 병렬적으로 추출함

                zip(list1, list2)
                # (a[0], b[0]), (a[1], b[1]), (a[2], b[2])
        - 단, 리스트의 갯수가 제일 적은 것으로 결정 됨

- ##### Reduce
    - reduce는 반복 가능한 객체의 각 요소를 지정된 함수로 처리한 뒤 이전 결과와 누적해서 반환
    - 내장 함수가 아니라 functools 모듈에서 reduce 함수를 가져와야 함

            reduce(function, iterable, initalizer=None)
    
            reduce(lambda x,y: x+y, array2dim)
            # [[], [1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
            #  []  [1]
            # -----------
            #           [2, 2]
            # ---------------------
            #                    [3, 3, 3]
            # -------------------------------
            #                               [4, 4, 4, 4]

            => [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]

- ##### Generator
    - yield 키워드를 사용하여 iterator를 반환하는 특별한 함수
    - 일반 함수와 달리 한번에 모든 값을 반환하지 않고 필요할 때마다 하나씩 값을 생성(계산)한다.
    - 이를 통해 메모리 사용을 최소화 하고, 큰 데이터셋이나 무한 시퀸스 같은 상황에서도 효율적으로 데이터를 처리할 수 있다.

            def generator_squares():
                for x in range(10):
                    yield x*x
            
            squares = generator_squares()

            print(next(squares)) # 0*0
            print(next(squares)) # 1*1
            print(next(squares)) # 2*2
            # ~~~
            print(next(squares)) # 9*9
            print(next(squares)) # StopIteration Error 발생 - 한도를 벗어남

- 표준 출력
    - print(value, sep='', end='\n', file=sys.stdout, flush=False)
    - value: 표현할 값
    - sep: 구분자
    - end: 끝날 때 연결할 것
    - file: 어떤 파일을 열 것인가?
    - flush: 매번 반영할 것인지

- 외부 파일 열기
    - 항상 open이 있으면 close도 있어야 한다.
    - open 시 (w:쓰기모드, r:읽기모드, a:추가모드) 설정
    - close 전 까지는 메모리에 해당내용을 기록하고 있어 반영이 되지 않는다.
    - close가 된다면 비로소 메모리에 있는 내용들이 기록 된다.
    - with를 사용하면 자동적으로 끝나는 부분에 close가 실행된다.

- flush
    - 스트림 객체로 바꿔서 출력을 해주고 있다 라는 뜻.
    - 객체를 그때그때 잘라서 보낸다.

### 2. 문자열 메소드
- rowString: 문자열을 있는 그대로 표현하기 위해 사용

        # 멀티라인 따옴표 3개
        # 공백, 엔터도 문자로 처리
        """안
        녕
        하
        세요
        """
        # 안\n녕\n하\n세요\n

        print('C:\0ITStudy')
        # C:ITStudy
        print(r'C:\0ITStudy')
        # C:\0ITStudy

- split('기준문자', 분리 횟수): 문자열에서 '기준문자'를 기준으로 분리횟수만큼 분리한 문자열의 **리스트**를 반환

        str1 = '안녕/안녕/안녕하세요/반가워요/좋은아침입니다'

        str1.split('/', 2)
        # ['안녕', '안녕', '안녕하세요/반가워요/좋은아침입니다']

- replace(기존 문자, 새로운 문자[, 몇번?])
    - 조건에 맞는 문자열을 치환
    - 메모장에 있는 바꾸기 기능과 동일

- strip(defaul='공백')
    - 문자열의 앞, 뒤에 존재하는 whitespace(공백, 탭, 엔터 등)를 전부 제거
    - 문자열의 마지막에 뉴라인의 존재 여부
    - 불필요한 문자들은 전부 제거할 수 있다.
    - 문자열 중간에 있는 화이트 스페이스는 제거되지 않는다.

            str='       공백 제거       '
            str=str.strip()
            # str -> '공백 제거'

    - 사이에 있는 공백이나 문자를 제거하려면 replace 활용

- join(반복가능한 객체)
    - 여러개의 문자열을 하나의 문자열로 합쳐서 새 문자열로 돌려준다.

            '*'.join(['1','2','3','4'])
            # => '1*2*3*4'

- casefold()
    - 기본적으로 lower()랑 같음
    - 다른 나라(독일 등)의 유니코드 문자를 소문자로 돌려줌

- find('찾을 문자'[, 시작 index[, 끝 index]])
    - 문자열에 포함된 첫번째 요소의 index값 반환
    - 찾고자하는 특정 문자열이 여러 개인 경우에는 최초 발견한 원소의 시작위치만 알려준다. (단 1개만 반환)
    - 여러개 찾을 때는 re 모듈의 finditer 활용

### 3. 정규식
##### 특정 조건 또는 패턴을 치환하는 과정을 쉽게 처리할 수 있는 방법

내장함수에는 없고, re 모듈을 import하여 사용해야만 한다.
- match(): 문자열의 첫 시작부터 정규식과 매치되는지 조사한다.
- search(): 문자열 전체를 검색하여 정규식과 매치되는지 조사한다.
- findall(): 정규식과 매치되는 모든 문자열(substring)을 **리스트**로 돌려준다.
- finditer(): 정규식과 매치되는 모든 문자열(substring)을 반복가능한 객체로 돌려준다.

사용하는 방법

    import re

    # 객체로 생성하여 패턴을 저장
    p = re.compile('패턴')
    p.method(데이터)

- 정규식 패턴
    - [ ]: 대괄호 안 1개의 문자 1개
    - [^ ]: 대괄호 안 1개의 문자와 일치하지 않는 문자랑 매치
    - [ ]+: 대괄호 안 1개의 문자와 매치하는 1개 이상의 문자들
    - [abc]: a 또는 b 또는 c의 문자들 중 한개의 문자와 매치
    - [0-9]: 0~9사이 숫자들 중 1개와 매치 (\d)
    - [^0-9]: 0~9 숫자랑 매치하지 않는 문자랑 매치(\D)
    - \s: whitespace 문자와 매치
    - \S: whitespace 문자 빼고 매치
    - \w: 문자+숫자로 구성된 문자와 매치, [a-zA-Z0-9]랑 동일
    - \W: 문자+숫자로 구성되지 않은 문자와 매치

- 정규식 예시

        import re

        test_string = '''happy happy dappy happyis HAPPY HaPpy Happy
        Happy Happy'''

        # H또는 h만으로 구성된 1개 이상의 문자열 출력
        p = re.compile('[hH]+')

        # happy로 이루어진 문자열 출력
        p = re.compile('happy')

        # flag
        # re.I: 패턴의 대소문자를 무시함
        # re.M: 띄어쓰기, 엔터를 기준으로 자동으로 나누어서 판단함

- re.sub()
패턴과 일치하는 문자를 바꿔줌
해당 패턴을 그대로 불러오는 grouping 방법도 활용

        import re

        name = 'SAGA NAMU'

        # 공백이 아닌 한 문자를 기준으로 1개는 그대로 작성하고, 한개는 *로 치환
        re.sub(r'(\S)(\S)', r'\1*', name)
        # S*G* N*M*

        # 공백이 아닌 첫글자랑 끝글자 빼고, 그 사이는 *로 치환
        re.sub(r'(\S)(\S+)(\S), lambda x: x.group(1) + '*' * len(x.group(2)) + x.group(3), name)
        # S**A N**U

정규식은 패턴을 잘 선별하여 찾아야 함